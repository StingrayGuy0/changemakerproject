<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Changemaker project</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    :root {
        --accent1: #38bdf8;
        --accent2: #0ea5e9;
        --bg: #0f172a;
        --up-color: #c084fc;
    }

    /* ==== Animated Background ==== */
    body {
        background: linear-gradient(120deg, #0d1a2f, #133a4e, #17657c, #1b8d9b);
        background-size: 400% 400%;
        animation: gradientShift 30s ease infinite;
        font-family: 'Orbitron', sans-serif;
        text-align: center;
        color: aliceblue;
        margin: 0;
        padding: 2rem;
        min-height: 100vh;
    }

    @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    h1 { color: var(--accent1); text-shadow: 0 0 20px var(--accent1), 0 0 40px var(--accent2); margin-bottom: 1rem; }

    /* Layout */
    .main {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      align-items: start;
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .card {
        background: rgba(255,255,255,0.05);
        border: 1px solid var(--accent1);
        border-radius: 1rem;
        padding: 1rem;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 20px rgba(56,189,248,0.6);
        text-align: left;
        position: relative;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
    }
    .card:hover { transform: translateY(-4px); box-shadow: 0 8px 25px rgba(56,189,248,0.7); }

    .task {
        position: relative; /* for float text */
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        padding: 0.25rem 0.5rem;
        border-radius: 0.6rem;
        border-left: 3px solid transparent;
        transition: background 0.3s ease, border-color 0.3s ease;
    }
    .task[data-status="incomplete"] { background: rgba(56,189,248,0.08); border-left-color: rgba(56,189,248,0.5); }
    .task.completed { text-decoration: line-through; opacity: 0.7; background: rgba(0,0,0,0.3); }

    .task .title { font-weight: bold; color: white; }
    .task .meta { font-size: 0.9rem; color: #cfeffd; }

    button {
        background: var(--accent1);
        border: none;
        color: black;
        font-weight: bold;
        padding: 0.25rem 0.75rem;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    button:hover { transform: translateY(-3px); box-shadow: 0 6px 18px rgba(0,0,0,0.35); }

    .section-title { color: var(--accent2); text-shadow: 0 0 10px var(--accent1); margin-top: 0; margin-bottom: 0.5rem; }
    .progress-bar { background: rgba(255,255,255,0.06); border: 1px solid var(--accent1); border-radius: 9999px; height: 18px; margin-top: 0.5rem; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent1), var(--accent2)); width: 0%; transition: width 0.5s ease; box-shadow: 0 0 10px var(--accent1); }
    .xp { color: var(--accent1); margin-top: 0.5rem; font-size: 1.05rem; }
    .level { color: #4ade80; margin-top: 0.25rem; font-size: 1rem; }
    .streak { color: gold; margin-top: 0.25rem; font-size: 1rem; text-shadow: 0 0 10px gold; }
    .badges { margin-top: 0.5rem; display:flex; flex-wrap:wrap; gap:0.3rem; }
    .badge { display: inline-block; background: linear-gradient(135deg, var(--accent1), var(--accent2)); color: black; padding: 0.25rem 0.5rem; border-radius: 9999px; font-size: 0.8rem; box-shadow: 0 0 5px var(--accent1); }

    .up-pip { color: var(--up-color); font-weight:900; }

    /* orb */
    #orb {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        margin: 0.8rem auto;
        display: block;
        background:
          radial-gradient(circle at 20% 80%, #0010d9 0%, rgba(0,0,0,0) 60%) no-repeat,
          radial-gradient(circle at 80% 20%, #00f6e1 0%, rgba(0,0,0,0) 60%) no-repeat,
          linear-gradient(135deg, #28303a, #2f2f35);
        background-blend-mode: screen;
        box-shadow: 0 0 25px rgba(56, 189, 248, 0.6), 0 0 50px rgba(14, 165, 233, 0.4);
        cursor: pointer;
        user-select: none;
        transition: transform 0.12s ease;
        animation: orbFlow 14s linear infinite, orbHue 16s linear infinite, orbPulse 2.5s ease-in-out infinite;
    }

    @keyframes orbFlow {
        0% { background-position: 20% 80%, 80% 20%; }
        25% { background-position: 30% 70%, 70% 30%; }
        50% { background-position: 80% 15%, 15% 85%; }
        75% { background-position: 70% 85%, 20% 20%; }
        100% { background-position: 20% 80%, 80% 20%; }
    }
    @keyframes orbHue {
        0% { filter: hue-rotate(0deg); }
        50% { filter: hue-rotate(90deg); }
        100% { filter: hue-rotate(0deg); }
    }
    @keyframes orbPulse {
        0%, 100% { box-shadow: 0 0 25px rgba(56, 189, 248, 0.6), 0 0 50px rgba(14, 165, 233, 0.4); }
        50% { box-shadow: 0 0 45px rgba(56, 189, 248, 0.9), 0 0 90px rgba(14, 165, 233, 0.7); }
    }

    /* float text animation (SP pop) */
    .float-text {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: -10px;
        color: var(--accent1);
        font-weight: 900;
        text-shadow: 0 0 6px var(--accent2);
        pointer-events: none;
        animation: floatUp 1000ms ease-out forwards;
    }
    @keyframes floatUp {
        0% { opacity: 1; transform: translate(-50%, 0) scale(1); }
        60% { opacity: 1; transform: translate(-50%, -28px) scale(1.15); }
        100% { opacity: 0; transform: translate(-50%, -48px) scale(1.3); }
    }

    /* Leaderboard fixed panel */
    #leaderboardCard {
        position: fixed;
        top: 2rem;
        right: 2rem;
        background: rgba(255,255,255,0.04);
        border: 1px solid var(--accent1);
        border-radius: 1rem;
        padding: 0.75rem;
        width: 260px;
        height: 20vh;
        overflow: hidden;
        backdrop-filter: blur(8px);
        box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        z-index: 50;
        transition: transform 0.3s ease, max-height 0.4s cubic-bezier(0.4,0,0.2,1), height 0.4s cubic-bezier(0.4,0,0.2,1), padding 0.3s;
        max-height: 350px;
        display: flex;
        flex-direction: column;
    }
    #leaderboardCard:hover { transform: scale(1.03); }
    #leaderboardCard h3 { margin: 0 0 0.5rem 0; color: var(--accent2); display: inline-block; }
    .leader-item { padding: 0.4rem 0.35rem; border-bottom: 1px dashed rgba(255,255,255,0.03); color: #cfeffd; font-weight:700; }
    /* Collapsible leaderboard panel */
    #leaderboardToggleBtn {
        position: absolute;
        top: 0.6rem;
        right: 0.7rem;
        background: none;
        color: var(--accent2);
        border: none;
        font-size: 1.3rem;
        cursor: pointer;
        padding: 0.1rem 0.3rem;
        z-index: 10;
        transition: color 0.2s;
    }
    #leaderboardToggleBtn:hover {
        color: var(--accent1);
    }
    #leaderboardCard.collapsed {
        height: 2.5rem;
        max-height: 2.5rem;
        min-height: 0;
        padding-bottom: 0.3rem;
        overflow: hidden;
        transition: transform 0.3s, max-height 0.4s cubic-bezier(0.4,0,0.2,1), height 0.4s cubic-bezier(0.4,0,0.2,1), padding 0.3s;
    }
    #leaderboardCard.collapsed #leaderboard {
        opacity: 0;
        pointer-events: none;
        height: 0;
        margin: 0;
        padding: 0;
        transition: opacity 0.2s;
    }
    #leaderboardCard.collapsed h3 {
        opacity: 1;
        pointer-events: auto;
        height: auto;
        margin: 0 0 0.5rem 0;
        padding: 0;
        transition: opacity 0.2s;
    }
    #leaderboardCard.collapsed #leaderboardToggleBtn {
        top: 0.2rem;
    }

    /* upgrades container styling */
    .upgrades { display:flex; flex-direction:column; gap:0.5rem; margin-top:0.5rem; }
    .upgrade-row { display:flex; justify-content:space-between; align-items:center; gap:0.6rem; }
    .muted { color: #bfefff; font-size:0.9rem; }

    .buildings { display:grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap:0.6rem; margin-top:0.5rem; }
    .building { background: rgba(255,255,255,0.03); padding:0.5rem; border-radius:0.6rem; border:1px solid rgba(255,255,255,0.03); transition: background 0.3s ease; }
    .building:hover { background: rgba(56,189,248,0.08); }
    .achievement { background: rgba(255,255,255,0.02); padding:0.4rem; border-radius:0.4rem; margin:0.2rem 0; }

    .shop { display:flex; flex-direction:column; gap:0.5rem; margin-top:0.6rem; }
    .shop-item { display:flex; justify-content:space-between; align-items:center; padding:0.4rem; border-radius:0.5rem; background: rgba(255,255,255,0.02); transition: background 0.3s ease; }
    .shop-item:hover { background: rgba(56,189,248,0.08); }

    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
      #leaderboardCard { position: static; width: auto; max-height: none; margin-top: 1rem; }
    }
</style>
</head>
<body>
<h1>Fun studying</h1>

<div class="main">
  <div class="col">
    <div class="card">
        <h2 class="section-title">Progress</h2>
        <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
        <div class="xp" id="xp">XP: 0</div>
        <div class="level" id="level">Level: 1</div>
        <div class="streak" id="streak">Streak: 0</div>
        <div class="badges" id="badges"></div>
        <div id="studyPoints" style="margin-top:0.5rem;">Study Points: 0</div>
        <div id="upgradePoints" style="margin-top:0.25rem;"><span class="up-pip">UP:</span> <strong id="upCount">0</strong></div>
        <div class="muted" id="cpsDisplay">CPS: 0</div>
    </div>

    <div class="card">
        <h2 class="section-title">Incomplete Tasks</h2>
        <div id="incompleteTasks"></div>
    </div>

    <div class="card">
        <h2 class="section-title">Completed Tasks</h2>
        <div id="completedTasks"></div>
    </div>
  </div>

  <div class="col">
    <div class="card">
        <h2 class="section-title">Orb of knowlage</h2>
        <div id="orb" title="Click to gain Study Points"> </div>
        <div class="upgrades" id="upgrades">
          <!-- upgrade controls inserted here -->
        </div>

        <h3 style="margin-top:0.5rem; color:var(--accent2);">Buildings</h3>
        <div class="buildings" id="buildings"></div>
    </div>

    <div class="card">
        <h2 class="section-title">Actions / Shop (Spend UP)</h2>
        <div class="upgrade-row">
          <div>
            <div class="muted">Buy Click Upgrade (SP)</div>
            <div class="muted">Increase SP per click</div>
          </div>
          <button id="buyUpgrade">Buy</button>
        </div>

        <div class="upgrade-row" style="margin-top:0.6rem;">
          <div>
            <div class="muted">Buy Auto-Clicker (SP)</div>
            <div class="muted">Generates SP every second</div>
          </div>
          <button id="buyAuto">Buy</button>
        </div>

        <div style="margin-top:0.6rem;" class="muted">Assignments give <strong>Upgrade Points (UP)</strong> â€” spend UP below on permanent meta upgrades.</div>

        <div class="shop" id="upShop">
          <!-- UP shop items inserted here -->
        </div>

        <div style="margin-top:0.6rem;" class="muted">Auto-Clickers and SP upgrades persist to your account. UP upgrades are permanent across prestiges.</div>

        <!-- ADDED: Prestige button (was missing) -->
        <div style="margin-top:0.8rem; display:flex; justify-content:center;">
          <button id="btnPrestige">Prestige</button>
        </div>
    </div>
  </div>
</div>

<!-- Achievements and Stats -->
<div class="card" style="margin-top:1rem; max-width:1100px; margin-left:auto; margin-right:auto;">
  <h2 class="section-title">Achievements & Stats</h2>
  <div id="achievements"></div>
  <h3 style="margin-top:0.6rem; color:var(--accent2);">Stats</h3>
  <div id="stats" class="muted"></div>
</div>

<!-- Leaderboard pinned -->
<div id="leaderboardCard" aria-live="polite">
  <button id="leaderboardToggleBtn" aria-label="Collapse leaderboard" title="Collapse leaderboard">âˆ’</button>
  <h3>Leaderboard</h3>
  <div id="leaderboard"></div>
</div>

<script type="module">
/* Firebase + Upgrade-Points game logic integrated (fixed CPS + prestige button + global_cps shop item) */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
import {
  getFirestore, collection, query, where, getDocs, updateDoc,
  doc, setDoc, getDoc, orderBy, limit, arrayUnion, increment, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

const firebaseConfig = {
    apiKey: "AIzaSyCOAHU1cXBuW3PgyXtdLWGkZ2ayAKfCYBc",
    authDomain: "changemaker-fa1fd.firebaseapp.com",
    projectId: "changemaker-fa1fd",
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* DOM */
const incompleteEl = document.getElementById("incompleteTasks");
const completedEl = document.getElementById("completedTasks");
const xpEl = document.getElementById("xp");
const levelEl = document.getElementById("level");
const streakEl = document.getElementById("streak");
const progressEl = document.getElementById("progress");
const badgesEl = document.getElementById("badges");
const studyPointsEl = document.getElementById("studyPoints");
const upCountEl = document.getElementById("upCount");
const orbEl = document.getElementById("orb");
const buyUpgradeBtn = document.getElementById("buyUpgrade");
const buyAutoBtn = document.getElementById("buyAuto");
const upgradesContainer = document.getElementById("upgrades");
const leaderboardEl = document.getElementById("leaderboard");
const buildingsEl = document.getElementById("buildings");
const achEl = document.getElementById("achievements");
const statsEl = document.getElementById("stats");
const cpsDisplay = document.getElementById("cpsDisplay");
const upShopEl = document.getElementById("upShop");
const prestigeBtn = document.getElementById('btnPrestige');

/* State */
let uid;
let xp = 0, level = 1, streak = 0;
let studyPoints = 0, spPerClick = 1, upgradeLevel = 0;
let autoClickers = 0;
let multiplier = 1, prestige = 0;
let lastCompleted = null;
let lastActive = new Date();
let upgradePoints = 0; // NEW: Upgrade Points (UP)
let metaUpgrades = {}; // holds purchases bought with UP (permanent multipliers)
const xpPerLevel = 100;

// new: buildings & upgrades & stats
const buildingTypes = [
  { id: 'lamp', name: 'Study Lamp', baseCost: 50, baseCps: 0.5 },
  { id: 'group', name: 'Study Group', baseCost: 400, baseCps: 4 },
  { id: 'library', name: 'Library', baseCost: 3000, baseCps: 30 },
  { id: 'research', name: 'Research Hub', baseCost: 20000, baseCps: 150 }
];
let buildings = {}; // id -> count
let upgrades = {}; // misc upgrades
let totalClicks = 0, totalSP = 0, totalPrestiges = 0;
let achievements = {};

// autosave throttle
let pendingSave = false;
let saveTimer = null;

/* Helpers */
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function costFor(base, count){ return Math.ceil(base * Math.pow(1.15, count)); }
function spawnFloatText(containerEl, text, color = null){
  const floatEl = document.createElement("div");
  floatEl.className = "float-text";
  floatEl.textContent = text;
  if(color) floatEl.style.color = color;
  containerEl.appendChild(floatEl);
  setTimeout(()=> floatEl.remove(), 1050);
}

/* Auth + load user */
onAuthStateChanged(auth, async (user) => {
  if(!user){ window.location.href = "/changemakerproject"; return; }
  uid = user.uid;

  const userRef = doc(db, "users", uid);
  const userSnap = await getDoc(userRef);

  if(userSnap.exists()){
    const data = userSnap.data();
    xp = data.xp || 0;
    level = data.level || 1;
    streak = data.streak || 0;
    studyPoints = data.studyPoints || 0;
    spPerClick = data.spPerClick || 1;
    upgradeLevel = data.upgradeLevel || 0;
    autoClickers = data.autoClickers || 0;
    multiplier = data.multiplier || 1;
    prestige = data.prestige || 0;
    lastCompleted = data.lastCompleted ? new Date(data.lastCompleted.seconds * 1000) : null;
    lastActive = data.lastActive ? new Date(data.lastActive.seconds * 1000) : new Date();
    buildings = data.buildings || {};
    upgrades = data.upgrades || {};
    totalClicks = data.totalClicks || 0;
    totalSP = data.totalSP || 0;
    totalPrestiges = data.totalPrestiges || 0;
    achievements = data.achievements || {};
    upgradePoints = data.upgradePoints || 0; // load UP
    metaUpgrades = data.metaUpgrades || {};

    // offline progress: compute elapsed seconds and grant CPS * elapsed
    const now = new Date();
    const elapsed = Math.floor((now - lastActive) / 1000);
    if(elapsed > 5){
      const offlineGain = Math.round(getCPS() * elapsed * 0.6); // give 60% of potential
      if(offlineGain > 0){
        studyPoints += offlineGain;
        totalSP += offlineGain;
        spawnFloatText(upgradesContainer, `+${offlineGain} SP (offline)`);
      }
    }
  } else {
    // create initial user doc with fields used by the game
    buildings = {};
    upgrades = {};
    achievements = {};
    metaUpgrades = {};
    await setDoc(userRef, {
      xp:0, level:1, streak:0, studyPoints:0, spPerClick:1,
      upgradeLevel:0, autoClickers:0, multiplier:1, prestige:0, lastCompleted:null,
      lastActive: serverTimestamp(), buildings, upgrades, totalClicks:0, totalSP:0, totalPrestiges:0, achievements,
      upgradePoints:0, metaUpgrades
    });
  }

  updateProgress();
  await loadTasks();
  await loadLeaderboard();
  renderUpgradesUI();
  renderBuildingsUI();
  renderAchievements();
  renderUPShop();
  scheduleAutosave();
});

/* load tasks */
async function loadTasks(){
  incompleteEl.innerHTML = "";
  completedEl.innerHTML = "";

  const q = query(collection(db, "tasks"), where("assignedTo", "array-contains", uid));
  const snap = await getDocs(q);

  snap.forEach(docSnap => {
    const task = docSnap.data();
    const id = docSnap.id;

    // ensure completedBy exists
    task.completedBy = Array.isArray(task.completedBy) ? task.completedBy : [];

    const taskEl = document.createElement("div");
    taskEl.className = "task";
    // keep dataset consistent with css expectations
    taskEl.dataset.status = task.completedBy.includes(uid) ? "completed" : "incomplete";

    const left = document.createElement("div");
    left.innerHTML = `<div class="title">${task.title}</div><div class="meta">Difficulty: ${task.xp} â€” gives UP</div>`;

    const right = document.createElement("div");
    const btn = document.createElement("button");
    btn.textContent = task.completedBy.includes(uid) ? "âœ…" : "Complete";
    btn.onclick = () => completeTask(id, task, taskEl);
    right.appendChild(btn);

    taskEl.appendChild(left);
    taskEl.appendChild(right);

    if(task.completedBy.includes(uid)){
      taskEl.classList.add("completed");
      completedEl.appendChild(taskEl);
    } else {
      incompleteEl.appendChild(taskEl);
    }
  });
}

/* Complete a task => give Upgrade Points (UP) with improved balancing */
async function completeTask(taskId, task, taskEl){
  // Guard clause: prevent double-completion for this user
  if (task.completedBy && task.completedBy.includes(uid)) {
    return; // already completed by this user, no extra UP
  }
  // use arrayUnion to avoid race conditions
  try {
    await updateDoc(doc(db, "tasks", taskId), { completedBy: arrayUnion(uid) });
  } catch(e){ console.error('task update failed', e); }

  // streak logic
  const today = new Date();
  const lastDay = lastCompleted ? new Date(lastCompleted) : null;
  const diffDays = lastDay ? Math.floor((today - lastDay)/86400000) : null;

  if (!lastCompleted || diffDays === 1) { streak += 1; }
  else if (diffDays > 1) { streak = 1; }
  lastCompleted = today;

  // compute UP reward based on task difficulty (task.xp holds a difficulty number used previously)
  const baseDifficulty = typeof task.xp === "number" ? task.xp : Number(task.xp) || 0;
  // Improved balancing: rewardUP = clamp(Math.ceil(baseDifficulty/30),1,5)
  let rewardUP = clamp(Math.ceil(baseDifficulty / 30), 1, 5);
  // apply streak bonus: +3% per streak day, up to 10 days
  rewardUP = Math.ceil(rewardUP * (1 + Math.min(streak, 10) * 0.03));

  upgradePoints += rewardUP;

  // persist important fields now
  try {
    await updateDoc(doc(db, "users", uid), {
      streak, lastCompleted: serverTimestamp(), upgradePoints: increment(rewardUP), totalClicks: increment(1)
    });
  } catch(e){ console.error('user update error', e); }

  // visual float on task
  spawnFloatText(taskEl, `+${rewardUP} UP`, 'var(--up-color)');
  updateProgress();
  await loadTasks();
  await updateLeaderboardEntry();
  checkAchievements();
}

/* Orb clicking behavior with improved critical system and rebalanced gain */
orbEl.addEventListener("click", async () => {
  // golden orb chance influenced by meta upgrades, capped at 50%
  const baseCrit = 0.03;
  const critBonus = (metaUpgrades.critChance || 0) * 0.03;
  let critChance = baseCrit + critBonus;
  critChance = Math.min(critChance, 0.5); // never reaches 100%
  const critRoll = Math.random();
  const isGolden = critRoll < critChance;
  const critMult = isGolden ? 5 : 1;

  // click power affected by meta upgrade 'clickPower' which multiplies spPerClick
  const clickPowerMult = metaUpgrades.clickPower ? (1 + 0.5 * metaUpgrades.clickPower) : 1;
  // streak bonus: +1% per day, up to 10%
  const streakBonus = 1 + Math.min(streak, 10) * 0.01;
  const gain = Math.round(spPerClick * multiplier * clickPowerMult * streakBonus * critMult);

  studyPoints += gain;
  totalSP += gain;
  totalClicks += 1;
  xp = Math.floor(studyPoints / 10);
  level = Math.floor(xp / xpPerLevel) + 1;

  // orb click visual
  orbEl.style.transform = "scale(0.93)";
  setTimeout(()=> orbEl.style.transform = "scale(1)", 90);

  // spawn float near orb
  const float = document.createElement("div");
  float.className = "float-text";
  float.style.top = "-12px";
  float.style.left = "50%";
  float.textContent = `+${gain} SP${isGolden? ' âœ¨' : ''}`;
  orbEl.appendChild(float);
  setTimeout(()=> float.remove(), 1000);

  markDirty();
  updateProgress();
  await updateLeaderboardEntry();
  checkAchievements();
});

/* Buy click upgrade (SP economy, stronger scaling and rebalanced SP gain) */
buyUpgradeBtn.addEventListener("click", async () => {
  const cost = 50 * Math.pow(1.45, upgradeLevel); // even stronger scaling
  const c = Math.ceil(cost);
  if(studyPoints >= c){
    studyPoints -= c;
    upgradeLevel += 1;
    // SP per click gain is less snowbally
    spPerClick += Math.max(1, Math.floor(1 + upgradeLevel * 0.35));
    xp = Math.floor(studyPoints / 10);
    level = Math.floor(xp / xpPerLevel) + 1;
    markDirty();
    renderUpgradesUI();
    updateProgress();
    await updateLeaderboardEntry();
    spawnFloatText(upgradesContainer, `- ${c} SP`);
    checkAchievements();
  } else {
    buyUpgradeBtn.animate([{ transform: 'translateX(0)' }, { transform: 'translateX(-6px)' }, { transform: 'translateX(6px)' }, { transform: 'translateX(0)' }], { duration: 260 });
  }
});

/* Buy auto-clicker (SP economy) */
buyAutoBtn.addEventListener("click", async () => {
  const cost = Math.ceil(200 * Math.pow(1.22, autoClickers));
  if(studyPoints >= cost){
    studyPoints -= cost;
    autoClickers += 1;
    markDirty();
    renderUpgradesUI();
    updateProgress();
    await updateLeaderboardEntry();
    spawnFloatText(upgradesContainer, `- ${cost} SP`);
    checkAchievements();
  } else {
    buyAutoBtn.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-6px)' }, { transform: 'translateY(0)' }], { duration: 220 });
  }
});

/* UP Shop: spend Upgrade Points on permanent meta upgrades */
const UP_SHOP = [
  { id: 'clickPower', name: 'Double Click Power', desc: 'Increase click power permanently (stackable)', baseCost: 1 },
  { id: 'autoPower', name: 'Auto Efficiency', desc: 'Auto-clickers produce 2Ã— more (stackable)', baseCost: 2 },
  { id: 'buildBoost', name: 'Building Boost', desc: 'Buildings produce +25% per purchase', baseCost: 2 },
  { id: 'critChance', name: 'Critical Chance', desc: 'Increase golden orb chance by +3%', baseCost: 1 },
  { id: 'global_cps', name: 'Global CPS Boost', desc: 'Increase global CPS by +15% per purchase', baseCost: 3 },
  { id: 'prestigeBoost', name: 'Prestige Boost', desc: 'Permanent prestige multiplier +0.1', baseCost: 5 }
];

function renderUPShop(){
  upShopEl.innerHTML = '';
  for(const item of UP_SHOP){
    const owned = metaUpgrades[item.id] || 0;
    const cost = Math.ceil(item.baseCost * Math.pow(1.5, owned));
    const div = document.createElement('div');
    div.className = 'shop-item';
    div.innerHTML = `
      <div>
        <div style="font-weight:800;">${item.name} ${owned? `(x${owned})` : ''}</div>
        <div class="muted">${item.desc}</div>
      </div>
      <div>
        <div style="text-align:right;">Cost: <strong class="up-pip">${cost} UP</strong></div>
        <div style="margin-top:0.3rem;text-align:right;"><button data-id="${item.id}">Buy</button></div>
      </div>
    `;
    const btn = div.querySelector('button');
    btn.addEventListener('click', async () => {
      if(upgradePoints >= cost){
        upgradePoints -= cost;
        metaUpgrades[item.id] = (metaUpgrades[item.id]||0) + 1;
        // apply immediate effect for everything that isnt prestige
        if(item.id === 'prestigeBoost'){
          multiplier += 0.1; // small permanent boost
        }
        markDirty();
        renderUPShop();
        renderUpgradesUI();
        updateProgress();
        spawnFloatText(upShopEl, `- ${cost} UP`, 'var(--up-color)');
        await updateLeaderboardEntry();
      } else {
        btn.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-6px)' }, { transform: 'translateY(0)' }], { duration: 200 });
      }
    });
    upShopEl.appendChild(div);
  }
}

/* Prestige */
const MIN_PRESTIGE_LEVEL = 50;

async function doPrestige(){
  if(level < MIN_PRESTIGE_LEVEL){
    return alert(`Reach level ${MIN_PRESTIGE_LEVEL} to prestige.`);
  }
  if(!confirm("Prestiging will reset SP, buildings, and SP-upgrades but UP and UP-upgrades remain permanent. Proceed?")) return;
  prestige += 1;
  totalPrestiges += 1;
  // grant a prestige reward that is weaker than UP but still meaningful
  multiplier *= 1.5; // prestige multiplier
  // reset SP-related progression but keep upgradePoints/metaUpgrades
  studyPoints = 0;
  xp = 0; level = 1;
  spPerClick = 1; upgradeLevel = 0; autoClickers = 0; buildings = {};

  try{
    await updateDoc(doc(db, "users", uid), { prestige, multiplier, studyPoints, xp, level, spPerClick, upgradeLevel, autoClickers, buildings, totalPrestiges: increment(1) });
  } catch(e){ console.error('prestige save failed', e); }

  renderUpgradesUI();
  renderBuildingsUI();
  updateProgress();
  await updateLeaderboardEntry();
  checkAchievements();
}

if(prestigeBtn) prestigeBtn.addEventListener('click', doPrestige);

/* render upgrades UI (status display) */
function renderUpgradesUI(){
  upgradesContainer.innerHTML = `
    <div class="muted">SP / click: <strong>${spPerClick}</strong></div>
    <div class="muted">Upgrade level: <strong>${upgradeLevel}</strong></div>
    <div class="muted">Auto-clickers: <strong>${autoClickers}</strong></div>
    <div class="muted">Prestige Ã—: <strong>${multiplier.toFixed(2)} (prestiges: ${prestige})</strong></div>
    <div class="muted">UP: <strong class="up-pip">${upgradePoints}</strong></div>
  `;
}

/* Buildings UI */
function renderBuildingsUI(){
  buildingsEl.innerHTML = '';
  for(const b of buildingTypes){
    const count = buildings[b.id] || 0;
    const cost = costFor(b.baseCost, count);
    const buildingBoost = (metaUpgrades.buildBoost || 0) * 0.25; // each purchase +25%
    const effectiveCps = b.baseCps * (1 + buildingBoost);
    const div = document.createElement('div');
    div.className = 'building';
    div.innerHTML = `
      <div style="font-weight:800;">${b.name}</div>
      <div class="muted">Count: <strong>${count}</strong></div>
      <div class="muted">CPS each: <strong>${(effectiveCps * (metaUpgrades.autoPower? (1 + 0.5*metaUpgrades.autoPower) : 1)).toFixed(2)}</strong></div>
      <div class="muted">Cost: <strong>${cost} SP</strong></div>
      <div style="margin-top:0.4rem;"><button data-id="${b.id}">Buy</button></div>
    `;
    const btn = div.querySelector('button');
    btn.addEventListener('click', async () => {
      if(studyPoints >= cost){
        studyPoints -= cost;
        buildings[b.id] = (buildings[b.id]||0) + 1;
        markDirty();
        renderBuildingsUI();
        updateProgress();
        spawnFloatText(buildingsEl, `- ${cost} SP`);
        await updateLeaderboardEntry();
        checkAchievements();
      } else {
        btn.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-6px)' }, { transform: 'translateY(0)' }], { duration: 200 });
      }
    });
    buildingsEl.appendChild(div);
  }
}

/* compute CPS from buildings + autoClickers */
function getCPS(){
  let cps = 0;
  // buildings contribution
  for(const b of buildingTypes){
    const count = buildings[b.id] || 0;
    const base = b.baseCps * count;
    cps += base;
  }
  // autoClickers yield spPerClick every 5s -> CPS contribution (per-second)
  const autoPowerMultiplier = metaUpgrades.autoPower ? (1 + 0.5*metaUpgrades.autoPower) : 1;
  cps += (autoClickers * (spPerClick * autoPowerMultiplier)) / 5;

  // global building multiplier from meta upgrades
  const globalMultiplier = 1 + (metaUpgrades.buildBoost || 0) * 0.25;
  cps = cps * globalMultiplier;

  // optional global CPS upgrades
  if(metaUpgrades.global_cps) cps *= 1 + metaUpgrades.global_cps*0.15;

  // apply prestige multiplier once (do not double-apply)
  cps = cps * multiplier;

  return cps;
}

//building autosave thing
setInterval(async () => {
  if(!uid) return;
  const cps = getCPS();
  if(cps > 0){
    // add fractional CPS (avoids losing small builds under 1 cps)
    studyPoints += cps;
    totalSP += cps;
    xp = Math.floor(studyPoints / 10);
    level = Math.floor(xp / xpPerLevel) + 1;
    markDirty();
    updateProgress();
    // persist less frequently (throttled)
  }
}, 1000);

// no idea what this is friend did
function markDirty(){
  pendingSave = true;
  if(saveTimer) return;
  saveTimer = setTimeout(async () => {
    await flushSave();
    saveTimer = null;
  }, 15000);
}

async function flushSave(){
  if(!pendingSave || !uid) return;
  pendingSave = false;
  try {
    await updateDoc(doc(db, 'users', uid), {
      studyPoints: Math.floor(studyPoints), xp, level, spPerClick, upgradeLevel, autoClickers, multiplier, prestige, buildings, upgrades, totalClicks, totalSP: Math.floor(totalSP), lastActive: serverTimestamp(), achievements, upgradePoints, metaUpgrades
    });
    await updateLeaderboardEntry();
  } catch(e){ console.error('flush save failed', e); }
}

//ui updates
function updateProgress(){
  xpEl.textContent = `XP: ${xp}`;
  levelEl.textContent = `Level: ${level}`;
  streakEl.textContent = `Streak: ${streak}`;
  studyPointsEl.textContent = `Study Points: ${Math.floor(studyPoints)}`;
  upCountEl.textContent = `${upgradePoints}`;
  const pct = ((xp % xpPerLevel) / xpPerLevel) * 100;
  progressEl.style.width = `${clamp(pct,0,100)}%`;

  badgesEl.innerHTML = "";
  const badgeDays = [1,3,5,7,10];
  for(let d of badgeDays){
    if(streak >= d){
      const b = document.createElement("span");
      b.className = "badge";
      b.textContent = `ðŸ”¥ ${d}-Day`;
      badgesEl.appendChild(b);
    }
  }
  if(prestige > 0){
    const p = document.createElement("span");
    p.className = "badge";
    p.textContent = `âœ¨ Prestige Ã—${multiplier.toFixed(2)}`;
    badgesEl.appendChild(p);
  }

  // update action buttons labels with new scaling
  buyUpgradeBtn.textContent = `Buy (${Math.ceil(50 * Math.pow(1.45, upgradeLevel))} SP)`;
  buyAutoBtn.textContent = `Buy Auto (${Math.ceil(200 * Math.pow(1.22, autoClickers))} SP)`;

  //CPS display
  const cps = getCPS();
  cpsDisplay.textContent = `CPS: ${cps.toFixed(2)}`;

  // stats
  statsEl.textContent = `Total clicks: ${totalClicks} â€¢ Total SP: ${Math.floor(totalSP)} â€¢ Prestiges: ${totalPrestiges}`;
}

/* Achievements */
function checkAchievements(){
  let changed = false;
  //simple achievements
  if(!achievements['click_100'] && totalClicks >= 100){ achievements['click_100'] = true; spawnFloatText(achEl, 'Achievement: 100 Clicks'); changed = true; }
  if(!achievements['sp_1000'] && totalSP >= 1000){ achievements['sp_1000'] = true; spawnFloatText(achEl, 'Achievement: 1,000 SP'); changed = true; }
  if(!achievements['prestige_1'] && prestige >= 1){ achievements['prestige_1'] = true; spawnFloatText(achEl, 'Achievement: First Prestige'); changed = true; }
  if(!achievements['7_streak'] && streak >= 7){ achievements['7_streak'] = true; spawnFloatText(achEl, 'Achievement: 7-Day Streak'); changed = true; }
  if(!achievements['up_10'] && upgradePoints >= 10){ achievements['up_10'] = true; spawnFloatText(achEl, 'Achievement: 10 UP earned'); changed = true; }
  if(changed) renderAchievements();
}

function renderAchievements(){
  achEl.innerHTML = '';
  const mapping = {
    'click_100': 'Clicked 100 times',
    'sp_1000': 'Earned 1,000 SP',
    'prestige_1': 'First Prestige',
    '7_streak': '7-Day Streak',
    'up_10': 'Earned 10 UP'
  };
  for(const k in mapping){
    const el = document.createElement('div');
    el.className = 'achievement';
    el.textContent = `${mapping[k]} ${achievements[k]? 'âœ…' : 'âŒ›'}`;
    achEl.appendChild(el);
  }
}

//leaderboard needs this
async function updateLeaderboardEntry(){
  try {
    await setDoc(doc(db, "leaderboard", uid), {
      uid,
      studyPoints: Math.floor(studyPoints),
      xp,
      level,
      upgradePoints,
      displayName: auth.currentUser.email || "Student"
    });
    await loadLeaderboard();
  } catch(e){
    console.error("Couldn't update leaderboard", e);
  }
}

async function loadLeaderboard(){
  try {
    // Build new leaderboard HTML in a temporary container
    const tempContainer = document.createElement('div');
    const q = query(collection(db, "leaderboard"), orderBy("studyPoints", "desc"), limit(10));
    const snap = await getDocs(q);
    if(snap.empty){
      tempContainer.textContent = "No data yet";
    } else {
      let place = 1;
      snap.forEach(docSnap => {
        const data = docSnap.data();
        const displayName = data.displayName || "Anonymous";
        const sp = typeof data.studyPoints === "number" ? data.studyPoints : 0;
        const lvl = typeof data.level === "number" ? data.level : 1;
        const up = typeof data.upgradePoints === "number" ? data.upgradePoints : 0;
        const div = document.createElement("div");
        div.className = "leader-item";
        div.textContent = `#${place} ${displayName} â€” ${sp} SP (Lv ${lvl}) â€¢ ${up} UP`;
        tempContainer.appendChild(div);
        place++;
      });
    }
    // Only update DOM if changed to prevent flashing
    if (leaderboardEl.innerHTML !== tempContainer.innerHTML) {
      leaderboardEl.innerHTML = tempContainer.innerHTML;
    }
  } catch(e){
    console.error("Could not load leaderboard", e);
  }
}

//remember to do this or something will break
renderUpgradesUI();
updateProgress();
renderBuildingsUI();
renderAchievements();
renderUPShop();

// flush every once in awhile, fix the infinite people thing
setInterval(() => { if(uid) flushSave(); }, 60000);

//auto save 
function scheduleAutosave(){
  setInterval(() => {
    if(uid) markDirty();
  }, 30000);
}

</script>
<script>
// Collapsible leaderboard panel
const leaderboardCard = document.getElementById('leaderboardCard');
const leaderboardToggleBtn = document.getElementById('leaderboardToggleBtn');
if (leaderboardToggleBtn && leaderboardCard) {
  leaderboardToggleBtn.addEventListener('click', () => {
    leaderboardCard.classList.toggle('collapsed');
    if(leaderboardCard.classList.contains('collapsed')) {
      leaderboardToggleBtn.innerHTML = '+';
      leaderboardToggleBtn.setAttribute('aria-label', 'Expand leaderboard');
      leaderboardToggleBtn.setAttribute('title', 'Expand leaderboard');
    } else {
      leaderboardToggleBtn.innerHTML = 'âˆ’';
      leaderboardToggleBtn.setAttribute('aria-label', 'Collapse leaderboard');
      leaderboardToggleBtn.setAttribute('title', 'Collapse leaderboard');
    }
  });
}
</script>
</body>
</html>
